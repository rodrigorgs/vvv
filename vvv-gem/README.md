# VVV

VVV is a set of scripts that support the creation of data analysis pipelines written in R and Ruby. These are the main features of such a pipeline:

* it is composed by scripts that read files, perform some computation, and write files
* dependencies between scripts are determined by the files they read and write
* scripts may be time-intensive, so we don't want to run them needlessly
* a script may be reused for multiple data sets
* scripts may be need to written and tested interactively, by trial and error

## Installation

You'll need Ruby and rubygems. Then, install vvv:

    gem install vvv

Other dependencies you'll need:

* GNU Make
* knitr (R package)
* rjson (R package)
* stringr (R package)

# Getting started

## Creating a project

To start a new project, create a directory for the project and, from inside the directory, run the command `vvv-create`:

    vvv-create

This command will create the files and directories of the project structure:

    Vvvfile   - VVV configuration
    template/ - R and Ruby meta-scripts (each one can be used to generate one or more scripts)
    script/   - generated scripts
    lib/      - libraries used by the scripts
    raw-data/ - raw data files distributed with the project
    data/     - data files generated by the scripts
    report/   - report of scripts' outputs
    doc/      - auto-generated documentation

The `lib/` directory contains initially two libraries: `variability.R` and `variability.rb`.

## Creating a simple script

Create two scripts, `template/first.R` and `template/second.R`, with the following contents:

    # template/first.R
    source('../lib/variability.R')
    set.seed("1")
    data <- rnorm(3)
    vvv_output <- '../data/a'
    writeLines(data, vvv_eval(vvv_output))

    # template/second.R
    source('../lib/variability.R')
    vvv_input <- '../data/a'
    x <- readLines(vvv_input)
    vvv_output <- '../data/b'
    writeLines(c(x, x), vvv_eval(vvv_output))

The lib `variability.R` should be included in all R files. It contains the definition of functions such as `vvv_eval`.

All scripts are run from their folder. This is why the lib is referenced by `../lib/variability.R`.

The statement `vvv_output <- ...` is essential for the project to work properly. This is how VVV knows that this script outputs a file called `../data/a`. It should appear for every file the script outputs.

The call to `vvv_eval` is in fact not needed in this example, but we'll keep it for consistency. The function `vvv_eval` will be explained in the appropriate moment.

## Running the simple script

Run the following commands:

    vvv-weave
    vvv-gen-makefile

The first command, `vvv-weave`, will create scripts from the templates. Because the templates are very simple, they will just be copied to the `script/` directory.

The second command, `vvv-gen-makefile`, will read the files in `scripts/` and create a `Makefile` that knows how to run the scripts in the correct order. This is possible because we have used the special markers `vvv_output` and `vvv_input`.

To run the scripts, run `make`. It will read the `Makefile` and call `vvv-run-script` for each script from within the `script/` directory. The execution reports for all scripts will be written in the `report/` directory. For R, the scripts are run using the `knitr` package.

If you run `make` again, nothing will happen because the data files were already created and are up-to-date. If you change a script, though, `make` will run only the scripts that need to be re-run.

## Scripts with variability

Now suppose that we have two data sets, `a1`, and `a2`, and we need to transform both using the same script and write the data sets `b1` and `b2`. We could use a for loop, but that would mean that if we ever need to change only one of the data sets, such as `a1`, we would needlessly run the transformation for `a2`, because the transformation script only knows how to transform all data sets.

With VVV, the preferred solution is to create a single script and use some conventions to parametrize the inputs and outputs. Let's modify the previous example:

    # template/multiple-%{number}.R
    source('../lib/variability.R')

    vvv_set('number', '1')

    set.seed(vvv_eval('%{number}'))
    data <- rnorm(3)

    vvv_output <- '../data/a%{number}'
    writeLines(data, vvv_eval(vvv_output))

First, notice that we renamed the script to `multiple-%{number}.R`. The `%{}` is a special notation to designate variables (in this case, `number`) that will be replaced by the appropriate values by `vvv-weave`.

The `%{}` notation is also used in parameters to the function `vvv_eval`. The function replaces, in runtime, the variables by their respective values.

But where do values come from? They should be specified in the `Vvvfile`, using JSON notation. Example:

    {
        scripts: {
            "multiple-%{number}.R": {
                "params": [
                    {"number": "1"},
                    {"number": "2"}
                ]
            }
        }
    }

Now run `vvv-weave` and observe that two files are created in `script/`: `multiple-1.R` and `multiple-2.R`. Observe how calls to `vvv_eval` where replaced by the result of parsing the string. Run `vvv-gen-makefile` and then `make` to see the magic happen.

## Running interactively (debugging)

What about `vvv_set`? What is it used for?

Well, data analysis is hard and we often need to run a single statement of a script in order to see if the results are what we expect before writing more source code lines. This is why R comes with a interactive interpreter and many editors allow us to run specific selected lines of a file in the interpreter.

When you use `vvv_eval` with a string such as "a%{number}", it needs to know what value of `number` to parse the string. While this value is provided by `vvv-weave`, that means we would no longer able to run the script in `template/`: for every change in the script template, we would have to run `vvv-weave` and then debug one of the scripts generated in `script/`. This is a tedious, error-prone process.

The solution is to use `vvv_set` to set values for variables that will be used only when running the script interactively. While a variable usually assumes multiple values (in our example, `number` can be 1 or 2), in `vvv_set` we choose an arbitrary value for testing purposes. When running in batch mode, using `make`, this value will be ignored.

## Reduce-type scripts

Some scripts will take multiple data sets and create a single data set. These are called *reduce-type* scripts. Here's how it should be configured in `Vvvfile`:

    {
        scripts: {
            "multiple-%{number}.R": {
                "variables": [
                    {"number": "1"},
                    {"number": "2"}
                ]
            },
            "sum.R": {
                "variables": [
                    {"number": "1"},
                    {"number": "2"}
                ],
                "reduce": true
            }
        }
    }

Example script:

    # template/sum.R
    source('../lib/variability.R')

    total <- 0
    for (param in vvv_variables('sum.R')$params) {
        vvv_set('number', param$number)
        vvv_input <- '../data/a%{number}'
        numbers <- readLines(vvv_eval(vvv_input))
        total += sum(numbers)
    }

    vvv_output <- '../data/total'
    writeLines(total, vvv_eval(vvv_output))

## Vis-flow (TODO)

Run `vvv-vis-flow`.